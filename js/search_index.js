var search_data = {"index":{"searchIndex":["certmaker","certificatefactory","certificatesuitegenerator","hash","io","packetthief","handlers","abstractsslhandler","proxyredirector","sslclient","sslserver","initialserver","sslsmartproxy","ssltransparentproxy","sslproxyconnection","transparentproxy","proxyconnection","impl","ipfw","ipfwrule","ipfwrulehandler","manual","nullrule","nullrulehandler","netfilter","iptablesrule","iptablesrulehandler","pfdivert","pfdivertrule","pfdivertrulehandler","pfrdr","pfrdrrule","pfrdrrulehandler","logging","redirectrule","util","ssltest","appcontext","certificatemanager","config","inputhandler","runner","ssltestcase","ssltestreport","ssltestresult","testlistener","_send_buffer()","_send_buffer()","action()","add_result()","cert_chain()","cert_matches_host()","check_for_hosttotest()","cleanup()","client_closed()","client_closed()","client_connected()","client_connected()","client_connected()","client_handshake_failed()","client_recv()","client_recv()","client_recv()","close_connection()","close_connection_after_writing()","connect()","connect_to_dest()","connect_to_dest()","create()","derive_time()","dest_cert_chain()","dest_closed()","dest_closed()","dest_connected()","dest_handshake_failed()","dest_recv()","dest_recv()","disable_raw_chars()","display_test()","doctor_cert()","enable_raw_chars()","generate_certificate()","generate_certificates()","get_cert()","get_chain()","get_key()","get_keychain()","get_raw_cert()","get_raw_key()","guess_implementation()","hosttotest()","implementation()","implementation=()","indifferent_fetch()","listener_port()","load_conf()","logfile()","loglevel()","lookup_cert()","make_ca()","make_certs()","method_missing()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","notify_readable()","notify_readable()","notify_writable()","notify_writable()","on()","on_test_completed()","original_dest()","original_dest()","original_dest()","original_dest()","original_dest()","packetthief()","parse_args()","passed?()","pause()","pause?()","post_init()","post_init()","post_init()","post_init()","preflight_for_cert()","print_results()","randomserial()","receive_data()","receive_data()","receive_data()","receive_data()","receive_data()","receive_data()","redirect()","redirect()","redirect()","redirect()","redirect()","redirect()","revert()","revert()","revert()","revert()","revert()","revert()","run()","run()","run()","run()","run()","run()","run()","run()","run_test()","send_data()","send_to_client()","send_to_client()","send_to_dest()","send_to_dest()","servername_cb()","servername_cb()","servername_cb()","servername_cb()","set_dest()","split_chain()","start()","stop_server()","stop_server()","stop_testing()","test_completed()","testing_method()","tests()","tls_begin()","tls_begin()","tls_failed_handshake()","tls_failed_handshake()","tls_failed_handshake()","tls_successful_handshake()","tls_successful_handshake()","tls_successful_handshake()","tls_successful_handshake()","to_csv()","to_h()","to_ipfw_command()","to_netfilter_command()","to_pf_command()","to_pf_command()","unbind()","unbind()","unbind()","unbind()","unbind()","unbind()","unbind()","unbind()","where()","write_buffer()","write_buffer=()","readme","general_setup","linux_setup"],"longSearchIndex":["certmaker","certmaker::certificatefactory","certmaker::certificatesuitegenerator","hash","io","packetthief","packetthief::handlers","packetthief::handlers::abstractsslhandler","packetthief::handlers::proxyredirector","packetthief::handlers::sslclient","packetthief::handlers::sslserver","packetthief::handlers::sslserver::initialserver","packetthief::handlers::sslsmartproxy","packetthief::handlers::ssltransparentproxy","packetthief::handlers::ssltransparentproxy::sslproxyconnection","packetthief::handlers::transparentproxy","packetthief::handlers::transparentproxy::proxyconnection","packetthief::impl","packetthief::impl::ipfw","packetthief::impl::ipfw::ipfwrule","packetthief::impl::ipfw::ipfwrulehandler","packetthief::impl::manual","packetthief::impl::manual::nullrule","packetthief::impl::manual::nullrulehandler","packetthief::impl::netfilter","packetthief::impl::netfilter::iptablesrule","packetthief::impl::netfilter::iptablesrulehandler","packetthief::impl::pfdivert","packetthief::impl::pfdivert::pfdivertrule","packetthief::impl::pfdivert::pfdivertrulehandler","packetthief::impl::pfrdr","packetthief::impl::pfrdr::pfrdrrule","packetthief::impl::pfrdr::pfrdrrulehandler","packetthief::logging","packetthief::redirectrule","packetthief::util","ssltest","ssltest::appcontext","ssltest::certificatemanager","ssltest::config","ssltest::inputhandler","ssltest::runner","ssltest::ssltestcase","ssltest::ssltestreport","ssltest::ssltestresult","ssltest::testlistener","packetthief::handlers::ssltransparentproxy#_send_buffer()","packetthief::handlers::transparentproxy#_send_buffer()","ssltest::config#action()","ssltest::ssltestreport#add_result()","packetthief::util::cert_chain()","ssltest::testlistener::cert_matches_host()","ssltest::testlistener#check_for_hosttotest()","ssltest::ssltestcase#cleanup()","packetthief::handlers::ssltransparentproxy#client_closed()","packetthief::handlers::transparentproxy#client_closed()","packetthief::handlers::proxyredirector#client_connected()","packetthief::handlers::ssltransparentproxy#client_connected()","packetthief::handlers::transparentproxy#client_connected()","packetthief::handlers::ssltransparentproxy#client_handshake_failed()","packetthief::handlers::ssltransparentproxy#client_recv()","packetthief::handlers::transparentproxy#client_recv()","ssltest::testlistener#client_recv()","packetthief::handlers::abstractsslhandler#close_connection()","packetthief::handlers::abstractsslhandler#close_connection_after_writing()","packetthief::handlers::sslclient::connect()","packetthief::handlers::ssltransparentproxy#connect_to_dest()","packetthief::handlers::transparentproxy#connect_to_dest()","certmaker::certificatefactory#create()","certmaker::certificatefactory#derive_time()","packetthief::handlers::ssltransparentproxy#dest_cert_chain()","packetthief::handlers::ssltransparentproxy#dest_closed()","packetthief::handlers::transparentproxy#dest_closed()","packetthief::handlers::ssltransparentproxy#dest_connected()","packetthief::handlers::ssltransparentproxy#dest_handshake_failed()","packetthief::handlers::ssltransparentproxy#dest_recv()","packetthief::handlers::transparentproxy#dest_recv()","io#disable_raw_chars()","ssltest::runner#display_test()","packetthief::handlers::sslsmartproxy#doctor_cert()","io#enable_raw_chars()","certmaker::certificatesuitegenerator#generate_certificate()","certmaker::certificatesuitegenerator#generate_certificates()","ssltest::certificatemanager#get_cert()","ssltest::certificatemanager#get_chain()","ssltest::certificatemanager#get_key()","ssltest::certificatemanager#get_keychain()","ssltest::certificatemanager#get_raw_cert()","ssltest::certificatemanager#get_raw_key()","packetthief::guess_implementation()","ssltest::config#hosttotest()","packetthief::implementation()","packetthief::implementation=()","hash#indifferent_fetch()","ssltest::config#listener_port()","ssltest::config::load_conf()","ssltest::config#logfile()","ssltest::config#loglevel()","packetthief::handlers::sslsmartproxy#lookup_cert()","certmaker::make_ca()","certmaker::make_certs()","packetthief::method_missing()","certmaker::certificatefactory::new()","certmaker::certificatesuitegenerator::new()","packetthief::handlers::abstractsslhandler::new()","packetthief::handlers::proxyredirector::new()","packetthief::handlers::sslserver::new()","packetthief::handlers::sslserver::initialserver::new()","packetthief::handlers::sslsmartproxy::new()","packetthief::handlers::ssltransparentproxy::new()","packetthief::handlers::ssltransparentproxy::sslproxyconnection::new()","packetthief::handlers::transparentproxy::proxyconnection::new()","packetthief::impl::ipfw::ipfwrule::new()","packetthief::impl::manual::nullrule::new()","packetthief::impl::netfilter::iptablesrule::new()","packetthief::impl::pfdivert::pfdivertrule::new()","packetthief::impl::pfrdr::pfrdrrule::new()","packetthief::redirectrule::new()","ssltest::appcontext::new()","ssltest::certificatemanager::new()","ssltest::config::new()","ssltest::inputhandler::new()","ssltest::runner::new()","ssltest::ssltestcase::new()","ssltest::ssltestreport::new()","ssltest::ssltestresult::new()","ssltest::testlistener::new()","packetthief::handlers::abstractsslhandler#notify_readable()","packetthief::handlers::sslserver::initialserver#notify_readable()","packetthief::handlers::abstractsslhandler#notify_writable()","packetthief::handlers::sslserver::initialserver#notify_writable()","ssltest::inputhandler#on()","ssltest::testlistener#on_test_completed()","packetthief::impl::ipfw::original_dest()","packetthief::impl::manual::original_dest()","packetthief::impl::netfilter::original_dest()","packetthief::impl::pfdivert::original_dest()","packetthief::impl::pfrdr::original_dest()","ssltest::config#packetthief()","ssltest::runner#parse_args()","ssltest::ssltestresult#passed?()","ssltest::runner#pause()","ssltest::config#pause?()","packetthief::handlers::abstractsslhandler#post_init()","packetthief::handlers::transparentproxy#post_init()","packetthief::handlers::transparentproxy::proxyconnection#post_init()","ssltest::testlistener#post_init()","packetthief::handlers::sslsmartproxy#preflight_for_cert()","ssltest::ssltestreport#print_results()","certmaker::certificatesuitegenerator#randomserial()","packetthief::handlers::abstractsslhandler#receive_data()","packetthief::handlers::ssltransparentproxy#receive_data()","packetthief::handlers::ssltransparentproxy::sslproxyconnection#receive_data()","packetthief::handlers::transparentproxy#receive_data()","packetthief::handlers::transparentproxy::proxyconnection#receive_data()","ssltest::inputhandler#receive_data()","packetthief::impl::ipfw::redirect()","packetthief::impl::manual::redirect()","packetthief::impl::netfilter::redirect()","packetthief::impl::pfdivert::redirect()","packetthief::impl::pfrdr::redirect()","packetthief::redirectrule#redirect()","packetthief::revert()","packetthief::impl::ipfw::ipfwrulehandler#revert()","packetthief::impl::manual::nullrulehandler#revert()","packetthief::impl::netfilter::iptablesrulehandler#revert()","packetthief::impl::pfdivert::pfdivertrulehandler#revert()","packetthief::impl::pfrdr::pfrdrrulehandler#revert()","packetthief::impl::ipfw::ipfwrulehandler#run()","packetthief::impl::manual::nullrulehandler#run()","packetthief::impl::netfilter::iptablesrulehandler#run()","packetthief::impl::pfdivert::pfdivertrulehandler#run()","packetthief::impl::pfrdr::pfrdrrulehandler#run()","packetthief::redirectrule#run()","ssltest::runner#run()","ssltest::ssltestcase#run()","ssltest::runner#run_test()","packetthief::handlers::abstractsslhandler#send_data()","packetthief::handlers::ssltransparentproxy#send_to_client()","packetthief::handlers::transparentproxy#send_to_client()","packetthief::handlers::ssltransparentproxy#send_to_dest()","packetthief::handlers::transparentproxy#send_to_dest()","packetthief::handlers::sslserver#servername_cb()","packetthief::handlers::sslsmartproxy#servername_cb()","packetthief::handlers::ssltransparentproxy#servername_cb()","ssltest::testlistener#servername_cb()","packetthief::impl::manual::set_dest()","packetthief::util::split_chain()","packetthief::handlers::sslserver::start()","packetthief::handlers::sslserver#stop_server()","packetthief::handlers::sslserver::initialserver#stop_server()","ssltest::ssltestcase#stop_testing()","ssltest::ssltestcase#test_completed()","ssltest::config#testing_method()","ssltest::config#tests()","packetthief::handlers::abstractsslhandler#tls_begin()","packetthief::handlers::sslclient#tls_begin()","packetthief::handlers::abstractsslhandler#tls_failed_handshake()","packetthief::handlers::ssltransparentproxy::sslproxyconnection#tls_failed_handshake()","ssltest::testlistener#tls_failed_handshake()","packetthief::handlers::abstractsslhandler#tls_successful_handshake()","packetthief::handlers::ssltransparentproxy#tls_successful_handshake()","packetthief::handlers::ssltransparentproxy::sslproxyconnection#tls_successful_handshake()","ssltest::testlistener#tls_successful_handshake()","ssltest::ssltestreport#to_csv()","ssltest::ssltestresult#to_h()","packetthief::impl::ipfw::ipfwrule#to_ipfw_command()","packetthief::impl::netfilter::iptablesrule#to_netfilter_command()","packetthief::impl::pfdivert::pfdivertrule#to_pf_command()","packetthief::impl::pfrdr::pfrdrrule#to_pf_command()","packetthief::handlers::abstractsslhandler#unbind()","packetthief::handlers::sslserver::initialserver#unbind()","packetthief::handlers::ssltransparentproxy#unbind()","packetthief::handlers::ssltransparentproxy::sslproxyconnection#unbind()","packetthief::handlers::transparentproxy#unbind()","packetthief::handlers::transparentproxy::proxyconnection#unbind()","ssltest::inputhandler#unbind()","ssltest::testlistener#unbind()","packetthief::redirectrule#where()","packetthief::handlers::abstractsslhandler#write_buffer()","packetthief::handlers::abstractsslhandler#write_buffer=()","","",""],"info":[["CertMaker","","CertMaker.html","",""],["CertMaker::CertificateFactory","","CertMaker/CertificateFactory.html","",""],["CertMaker::CertificateSuiteGenerator","","CertMaker/CertificateSuiteGenerator.html","","<p>Generates a suite of certificates from a configuration.\n<p>Config should be a hash-like with each key being …\n"],["Hash","","Hash.html","",""],["IO","","IO.html","","<p>Extends IO to enable “raw” input on TTYs.\n"],["PacketThief","","PacketThief.html","","<p>Framework for intercepting packets, redirecting them to a handler, and\ndoing something with the “stolen” …\n"],["PacketThief::Handlers","","PacketThief/Handlers.html","",""],["PacketThief::Handlers::AbstractSSLHandler","","PacketThief/Handlers/AbstractSSLHandler.html","","<p>Parent class for both SSLServer and SSLClient.\n<p>TODO: get_peer_cert, get_peername, etc.\n"],["PacketThief::Handlers::ProxyRedirector","","PacketThief/Handlers/ProxyRedirector.html","","<p>Instead of forwarding the connection to the original host, forwards it to a\nconfigured host instead. …\n"],["PacketThief::Handlers::SSLClient","","PacketThief/Handlers/SSLClient.html","","<p>Basic SSL/TLS Client built on Ruby’s OpenSSL objects instead of on\nEventMachine’s start_tls. This allows …\n"],["PacketThief::Handlers::SSLServer","","PacketThief/Handlers/SSLServer.html","","<p>Basic SSL/TLS Server built on Ruby’s OpenSSL objects instead of on\nEventMachine’s start_tls. This allows …\n"],["PacketThief::Handlers::SSLServer::InitialServer","","PacketThief/Handlers/SSLServer/InitialServer.html","","<p>Handles the initial listening socket. We can’t seem to use EM.start_server\n-&gt; EM.detach -&gt; em.watch …\n"],["PacketThief::Handlers::SSLSmartProxy","","PacketThief/Handlers/SSLSmartProxy.html","","<p>This SSL proxy needs a CA certificate (or chain) and private key. It then\nuses that information to automatically …\n"],["PacketThief::Handlers::SSLTransparentProxy","","PacketThief/Handlers/SSLTransparentProxy.html","","<p>Provides a transparent proxy for any TCP connection.\n"],["PacketThief::Handlers::SSLTransparentProxy::SSLProxyConnection","","PacketThief/Handlers/SSLTransparentProxy/SSLProxyConnection.html","","<p>Represents a connection out to the original destination.\n"],["PacketThief::Handlers::TransparentProxy","","PacketThief/Handlers/TransparentProxy.html","","<p>Provides a transparent proxy for any TCP connection.\n"],["PacketThief::Handlers::TransparentProxy::ProxyConnection","","PacketThief/Handlers/TransparentProxy/ProxyConnection.html","","<p>Represents a connection out to the original destination.\n"],["PacketThief::Impl","","PacketThief/Impl.html","","<p>PacketThief implementations. Each one contains the implementation details\nfor working with a given firewall. …\n"],["PacketThief::Impl::Ipfw","","PacketThief/Impl/Ipfw.html","","<p>Use Ipfw to redirect traffic.\n<p>Needed in at least Mac OS X 10.6 and later?:\n\n<pre>sysctl -w net.inet.ip.scopedroute=0</pre>\n"],["PacketThief::Impl::Ipfw::IpfwRule","","PacketThief/Impl/Ipfw/IpfwRule.html","",""],["PacketThief::Impl::Ipfw::IpfwRuleHandler","","PacketThief/Impl/Ipfw/IpfwRuleHandler.html","",""],["PacketThief::Impl::Manual","","PacketThief/Impl/Manual.html","","<p>PacketThief implementation that does apply any firewall rules. Furthermore,\nManual.original_dest will …\n"],["PacketThief::Impl::Manual::NullRule","","PacketThief/Impl/Manual/NullRule.html","",""],["PacketThief::Impl::Manual::NullRuleHandler","","PacketThief/Impl/Manual/NullRuleHandler.html","",""],["PacketThief::Impl::Netfilter","","PacketThief/Impl/Netfilter.html","","<p>PacketThief implemented using the Linux kernel’s Netfilter.\n<p>This is roughly equivalent to:\n<p>echo 1 &gt; …\n"],["PacketThief::Impl::Netfilter::IPTablesRule","","PacketThief/Impl/Netfilter/IPTablesRule.html","","<p>Adds IPTables specific details to a Redirectrule.\n"],["PacketThief::Impl::Netfilter::IPTablesRuleHandler","","PacketThief/Impl/Netfilter/IPTablesRuleHandler.html","","<p>Manages IPTablesRules. It actually runs the rule, and it tracks the rule so\nit can be deleted later. …\n"],["PacketThief::Impl::PFDivert","","PacketThief/Impl/PFDivert.html","","<p>Untested and likely broken PacketThief implementation that uses PF’s\ndivert-to to redirect traffic.  …\n"],["PacketThief::Impl::PFDivert::PFDivertRule","","PacketThief/Impl/PFDivert/PFDivertRule.html","",""],["PacketThief::Impl::PFDivert::PFDivertRuleHandler","","PacketThief/Impl/PFDivert/PFDivertRuleHandler.html","",""],["PacketThief::Impl::PFRdr","","PacketThief/Impl/PFRdr.html","","<p>Implementation that uses PF’s <code>rdr</code> (old style rules) and parses\npfctl’s output to interoperate with Mac …\n"],["PacketThief::Impl::PFRdr::PFRdrRule","","PacketThief/Impl/PFRdr/PFRdrRule.html","",""],["PacketThief::Impl::PFRdr::PFRdrRuleHandler","","PacketThief/Impl/PFRdr/PFRdrRuleHandler.html","",""],["PacketThief::Logging","","PacketThief/Logging.html","","<p>Mix-in that provides some private convenience logging functions. Uses the\n@logger instance variable. …\n"],["PacketThief::RedirectRule","","PacketThief/RedirectRule.html","",""],["PacketThief::Util","","PacketThief/Util.html","","<p>Some utility methods, currently just used by the examples.\n"],["SSLTest","","SSLTest.html","",""],["SSLTest::AppContext","","SSLTest/AppContext.html","","<p>Class to hold onto application-wide values in a single place and to track\napplication state.\n"],["SSLTest::CertificateManager","","SSLTest/CertificateManager.html","",""],["SSLTest::Config","","SSLTest/Config.html","",""],["SSLTest::InputHandler","","SSLTest/InputHandler.html","","<p>EM handler to handle keyboard input while a test is running.\n"],["SSLTest::Runner","","SSLTest/Runner.html","","<p>Handles a list of arguments, and uses the arguments to run a sequence of\ntests.\n"],["SSLTest::SSLTestCase","","SSLTest/SSLTestCase.html","","<p>Represents a single test case. It performs the test it represents and adds\nits result to a report.\n"],["SSLTest::SSLTestReport","","SSLTest/SSLTestReport.html","","<p>Represents an entire report. SSLTestCases add results to it, which it can\nlater format.\n"],["SSLTest::SSLTestResult","","SSLTest/SSLTestResult.html","","<p>SSLTestResults are created by running SSLTestCases. They are then added to\nan SSLTestReport so that they …\n"],["SSLTest::TestListener","","SSLTest/TestListener.html","","<p>TestListener is the real workhorse used by SSLTestCases. It builds on the\nSSLSmartProxy from PacketThief …\n"],["_send_buffer","PacketThief::Handlers::SSLTransparentProxy","PacketThief/Handlers/SSLTransparentProxy.html#method-i-_send_buffer","()",""],["_send_buffer","PacketThief::Handlers::TransparentProxy","PacketThief/Handlers/TransparentProxy.html#method-i-_send_buffer","()",""],["action","SSLTest::Config","SSLTest/Config.html#method-i-action","()",""],["add_result","SSLTest::SSLTestReport","SSLTest/SSLTestReport.html#method-i-add_result","(result)",""],["cert_chain","PacketThief::Util","PacketThief/Util.html#method-c-cert_chain","(raw)","<p>Extracts all PEM encoded certs from a raw string and returns a list of X509\ncertificate objects in the …\n"],["cert_matches_host","SSLTest::TestListener","SSLTest/TestListener.html#method-c-cert_matches_host","(cert, hostname)","<p>Return true if <em>cert</em>’s CNAME or subjectAltName matches hostname,\notherwise return false.\n"],["check_for_hosttotest","SSLTest::TestListener","SSLTest/TestListener.html#method-i-check_for_hosttotest","(actx)","<p>Replaces the certificates used in the SSLContext with the test certificates\nif the destination matches …\n"],["cleanup","SSLTest::SSLTestCase","SSLTest/SSLTestCase.html#method-i-cleanup","()",""],["client_closed","PacketThief::Handlers::SSLTransparentProxy","PacketThief/Handlers/SSLTransparentProxy.html#method-i-client_closed","()","<p>Called when the client connection closes. At present, it only provides\ninformational utility.\n"],["client_closed","PacketThief::Handlers::TransparentProxy","PacketThief/Handlers/TransparentProxy.html#method-i-client_closed","()","<p>Called when the client connection closes. At present, it only provides\ninformational utility.\n"],["client_connected","PacketThief::Handlers::ProxyRedirector","PacketThief/Handlers/ProxyRedirector.html#method-i-client_connected","()","<p>Instead of using the original destination, use the configured destination.\n"],["client_connected","PacketThief::Handlers::SSLTransparentProxy","PacketThief/Handlers/SSLTransparentProxy.html#method-i-client_connected","()","<p>This method is called when a client connects, and the TLS handhsake has\ncompleted. The default behavior …\n"],["client_connected","PacketThief::Handlers::TransparentProxy","PacketThief/Handlers/TransparentProxy.html#method-i-client_connected","()","<p>This method is called when a client connects. The default behavior is to\nbegin initating the connection …\n"],["client_handshake_failed","PacketThief::Handlers::SSLTransparentProxy","PacketThief/Handlers/SSLTransparentProxy.html#method-i-client_handshake_failed","()","<p>This method is called when the TLS handshake between the client and the\nproxy fails. It does nothing …\n"],["client_recv","PacketThief::Handlers::SSLTransparentProxy","PacketThief/Handlers/SSLTransparentProxy.html#method-i-client_recv","(data)","<p>This method is called when the proxy receives data from the client\nconnection. The default behavior is …\n"],["client_recv","PacketThief::Handlers::TransparentProxy","PacketThief/Handlers/TransparentProxy.html#method-i-client_recv","(data)","<p>This method is called when the proxy receives data from the client\nconnection. The default behavior is …\n"],["client_recv","SSLTest::TestListener","SSLTest/TestListener.html#method-i-client_recv","(data)",""],["close_connection","PacketThief::Handlers::AbstractSSLHandler","PacketThief/Handlers/AbstractSSLHandler.html#method-i-close_connection","()",""],["close_connection_after_writing","PacketThief::Handlers::AbstractSSLHandler","PacketThief/Handlers/AbstractSSLHandler.html#method-i-close_connection_after_writing","()",""],["connect","PacketThief::Handlers::SSLClient","PacketThief/Handlers/SSLClient.html#method-c-connect","(host, port, *args, &block)",""],["connect_to_dest","PacketThief::Handlers::SSLTransparentProxy","PacketThief/Handlers/SSLTransparentProxy.html#method-i-connect_to_dest","()","<p>Initiate the connection to @dest_host:@dest_port.\n"],["connect_to_dest","PacketThief::Handlers::TransparentProxy","PacketThief/Handlers/TransparentProxy.html#method-i-connect_to_dest","()","<p>Initiate the connection to @dest_host:@dest_port.\n"],["create","CertMaker::CertificateFactory","CertMaker/CertificateFactory.html#method-i-create","(args={})","<p>Returns an array containing the certificate and associated key with the\nconfigured attributes, plus with …\n"],["derive_time","CertMaker::CertificateFactory","CertMaker/CertificateFactory.html#method-i-derive_time","(timeval)","<p>Handle special time values.\n<p>now   Time.now 30    30 days from now -30   30 days before now\n"],["dest_cert_chain","PacketThief::Handlers::SSLTransparentProxy","PacketThief/Handlers/SSLTransparentProxy.html#method-i-dest_cert_chain","()","<p>Returns the certificate chain for the destination, or nil if the\ndestination connection does not exist …\n"],["dest_closed","PacketThief::Handlers::SSLTransparentProxy","PacketThief/Handlers/SSLTransparentProxy.html#method-i-dest_closed","()","<p>Called when the original destination connection closes. At present, it only\nprovides informational utility. …\n"],["dest_closed","PacketThief::Handlers::TransparentProxy","PacketThief/Handlers/TransparentProxy.html#method-i-dest_closed","()","<p>Called when the original destination connection closes. At present, it only\nprovides informational utility. …\n"],["dest_connected","PacketThief::Handlers::SSLTransparentProxy","PacketThief/Handlers/SSLTransparentProxy.html#method-i-dest_connected","()","<p>Called when the connection to and the TLS handshake between the proxy and\nthe destination succeeds.  …\n"],["dest_handshake_failed","PacketThief::Handlers::SSLTransparentProxy","PacketThief/Handlers/SSLTransparentProxy.html#method-i-dest_handshake_failed","(e)","<p>Called when the TLS handshake between the proxy and the destination fails.\n"],["dest_recv","PacketThief::Handlers::SSLTransparentProxy","PacketThief/Handlers/SSLTransparentProxy.html#method-i-dest_recv","(data)","<p>Called when the proxy receives data from the destination connection. The\ndefault behavior calls #dest_recv() …\n"],["dest_recv","PacketThief::Handlers::TransparentProxy","PacketThief/Handlers/TransparentProxy.html#method-i-dest_recv","(data)","<p>Called when the proxy receives data from the destination connection. The\ndefault behavior calls #dest_recv() …\n"],["disable_raw_chars","IO","IO.html#method-i-disable_raw_chars","()","<p>Reverts the termios state to what it was before calling #enable_raw_chars.\n"],["display_test","SSLTest::Runner","SSLTest/Runner.html#method-i-display_test","(test)",""],["doctor_cert","PacketThief::Handlers::SSLSmartProxy","PacketThief/Handlers/SSLSmartProxy.html#method-i-doctor_cert","(oldcert, cacert, key)","<p>Replace the issuer, the public key, and the signature.\n"],["enable_raw_chars","IO","IO.html#method-i-enable_raw_chars","()","<p>Enables raw character input for a TTY. It uses the ruby-termios gem to\ndisable ICANON and ECHO functionality. …\n"],["generate_certificate","CertMaker::CertificateSuiteGenerator","CertMaker/CertificateSuiteGenerator.html#method-i-generate_certificate","(calias, certinfo)",""],["generate_certificates","CertMaker::CertificateSuiteGenerator","CertMaker/CertificateSuiteGenerator.html#method-i-generate_certificates","()",""],["get_cert","SSLTest::CertificateManager","SSLTest/CertificateManager.html#method-i-get_cert","(name)",""],["get_chain","SSLTest::CertificateManager","SSLTest/CertificateManager.html#method-i-get_chain","(list)",""],["get_key","SSLTest::CertificateManager","SSLTest/CertificateManager.html#method-i-get_key","(name)",""],["get_keychain","SSLTest::CertificateManager","SSLTest/CertificateManager.html#method-i-get_keychain","(list)",""],["get_raw_cert","SSLTest::CertificateManager","SSLTest/CertificateManager.html#method-i-get_raw_cert","(name)",""],["get_raw_key","SSLTest::CertificateManager","SSLTest/CertificateManager.html#method-i-get_raw_key","(name)",""],["guess_implementation","PacketThief","PacketThief.html#method-c-guess_implementation","()",""],["hosttotest","SSLTest::Config","SSLTest/Config.html#method-i-hosttotest","()",""],["implementation","PacketThief","PacketThief.html#method-c-implementation","()",""],["implementation=","PacketThief","PacketThief.html#method-c-implementation-3D","(newimpl)",""],["indifferent_fetch","Hash","Hash.html#method-i-indifferent_fetch","(key, *extra)","<p>Light extension to hash to add indifferent fetching. Meant to be more\nlightweight than depending on  …\n"],["listener_port","SSLTest::Config","SSLTest/Config.html#method-i-listener_port","()",""],["load_conf","SSLTest::Config","SSLTest/Config.html#method-c-load_conf","(opts)",""],["logfile","SSLTest::Config","SSLTest/Config.html#method-i-logfile","()",""],["loglevel","SSLTest::Config","SSLTest/Config.html#method-i-loglevel","()",""],["lookup_cert","PacketThief::Handlers::SSLSmartProxy","PacketThief/Handlers/SSLSmartProxy.html#method-i-lookup_cert","(hostname=nil)","<p>Check a class-level cache for an existing doctored certificate that\ncorresponds to the requested hostname …\n"],["make_ca","CertMaker","CertMaker.html#method-c-make_ca","(config, verbose=false)","<p>Ensure that the custom ca exists.\n"],["make_certs","CertMaker","CertMaker.html#method-c-make_certs","(config, verbose=false)","<p>Generate certificates and keys using <code>config</code>.\n<p>Config is usually a data structure derived from parsing a …\n"],["method_missing","PacketThief","PacketThief.html#method-c-method_missing","(m, *args, &block)","<p>Pass the call on to @implementation, or an OS-specific default, if one is\nknown.\n"],["new","CertMaker::CertificateFactory","CertMaker/CertificateFactory.html#method-c-new","()",""],["new","CertMaker::CertificateSuiteGenerator","CertMaker/CertificateSuiteGenerator.html#method-c-new","(certinfos, defaulthostname, config={})","<p>certinfos should be a hash-like where each entry describes a certificate.\ndefaulthostname should be a …\n"],["new","PacketThief::Handlers::AbstractSSLHandler","PacketThief/Handlers/AbstractSSLHandler.html#method-c-new","(tcpsocket)",""],["new","PacketThief::Handlers::ProxyRedirector","PacketThief/Handlers/ProxyRedirector.html#method-c-new","(proxy_host, proxy_port)",""],["new","PacketThief::Handlers::SSLServer","PacketThief/Handlers/SSLServer.html#method-c-new","(tcpsocket)",""],["new","PacketThief::Handlers::SSLServer::InitialServer","PacketThief/Handlers/SSLServer/InitialServer.html#method-c-new","(servsocket, ssl_class, args, block)",""],["new","PacketThief::Handlers::SSLSmartProxy","PacketThief/Handlers/SSLSmartProxy.html#method-c-new","(tcpsocket, ca_chain, key)",""],["new","PacketThief::Handlers::SSLTransparentProxy","PacketThief/Handlers/SSLTransparentProxy.html#method-c-new","(tcpsocket)",""],["new","PacketThief::Handlers::SSLTransparentProxy::SSLProxyConnection","PacketThief/Handlers/SSLTransparentProxy/SSLProxyConnection.html#method-c-new","(tcpsocket, client_conn, ctx)","<p>Sets up references to the client proxy connection handler that created this\nhandler.\n"],["new","PacketThief::Handlers::TransparentProxy::ProxyConnection","PacketThief/Handlers/TransparentProxy/ProxyConnection.html#method-c-new","(client_conn)","<p>Sets up references to the client proxy connection handler that created this\nhandler.\n"],["new","PacketThief::Impl::Ipfw::IpfwRule","PacketThief/Impl/Ipfw/IpfwRule.html#method-c-new","(handler, rule_number=nil)",""],["new","PacketThief::Impl::Manual::NullRule","PacketThief/Impl/Manual/NullRule.html#method-c-new","(handler, rule_number=nil)",""],["new","PacketThief::Impl::Netfilter::IPTablesRule","PacketThief/Impl/Netfilter/IPTablesRule.html#method-c-new","(handler, table, chain)",""],["new","PacketThief::Impl::PFDivert::PFDivertRule","PacketThief/Impl/PFDivert/PFDivertRule.html#method-c-new","(handler, rule_number=nil)",""],["new","PacketThief::Impl::PFRdr::PFRdrRule","PacketThief/Impl/PFRdr/PFRdrRule.html#method-c-new","(handler, rule_number=nil)",""],["new","PacketThief::RedirectRule","PacketThief/RedirectRule.html#method-c-new","(handler)",""],["new","SSLTest::AppContext","SSLTest/AppContext.html#method-c-new","(config, cert_manager, logger)",""],["new","SSLTest::CertificateManager","SSLTest/CertificateManager.html#method-c-new","(certinfo)",""],["new","SSLTest::Config","SSLTest/Config.html#method-c-new","(opts)","<p>TODO: do some basic type validation on the config file.\n"],["new","SSLTest::InputHandler","SSLTest/InputHandler.html#method-c-new","(stdin=$stdin)",""],["new","SSLTest::Runner","SSLTest/Runner.html#method-c-new","(args, stdin, stdout)",""],["new","SSLTest::SSLTestCase","SSLTest/SSLTestCase.html#method-c-new","(appctx, report, testdesc)",""],["new","SSLTest::SSLTestReport","SSLTest/SSLTestReport.html#method-c-new","()",""],["new","SSLTest::SSLTestResult","SSLTest/SSLTestResult.html#method-c-new","(testcase_id, passed=false)",""],["new","SSLTest::TestListener","SSLTest/TestListener.html#method-c-new","(tcpsocket, cacert, cakey, hosttotest, chaintotest, keytotest, logger=nil)","<p>For all hosts that do not match <em>hosttotest</em>, we currently use the\n<em>cacert</em> and re-sign the original cert …\n"],["notify_readable","PacketThief::Handlers::AbstractSSLHandler","PacketThief/Handlers/AbstractSSLHandler.html#method-i-notify_readable","()","<p>Calls accept_nonblock/connect_nonblock, read_nonblock, or write_nonblock\nbased on the current state of …\n"],["notify_readable","PacketThief::Handlers::SSLServer::InitialServer","PacketThief/Handlers/SSLServer/InitialServer.html#method-i-notify_readable","()",""],["notify_writable","PacketThief::Handlers::AbstractSSLHandler","PacketThief/Handlers/AbstractSSLHandler.html#method-i-notify_writable","()","<p>We only care about notify_writable if we are waiting to write for some\nreason.\n"],["notify_writable","PacketThief::Handlers::SSLServer::InitialServer","PacketThief/Handlers/SSLServer/InitialServer.html#method-i-notify_writable","()",""],["on","SSLTest::InputHandler","SSLTest/InputHandler.html#method-i-on","(char, blk=nil, &block)",""],["on_test_completed","SSLTest::TestListener","SSLTest/TestListener.html#method-i-on_test_completed","(blk=nil, &block)",""],["original_dest","PacketThief::Impl::Ipfw","PacketThief/Impl/Ipfw.html#method-c-original_dest","(sock)","<p>Returns the [port, host] for the original destination of <code>sock</code>.\n<p><code>Sock</code> can be a Ruby socket or an EventMachine::Connection ...\n"],["original_dest","PacketThief::Impl::Manual","PacketThief/Impl/Manual.html#method-c-original_dest","(sock)","<p>Returns the [port, host] for the original destination of <code>sock</code>.\n<p>The Manual implementation only returns …\n"],["original_dest","PacketThief::Impl::Netfilter","PacketThief/Impl/Netfilter.html#method-c-original_dest","(socket)","<p>Returns the [port, host] for a socket or EM::Connection that whose\nconnection was redirected by netfilter …\n"],["original_dest","PacketThief::Impl::PFDivert","PacketThief/Impl/PFDivert.html#method-c-original_dest","(sock)","<p>Returns the [port, host] for the original destination of <code>sock</code>.\n<p><code>Sock</code> can be a Ruby socket or an EventMachine::Connection ...\n"],["original_dest","PacketThief::Impl::PFRdr","PacketThief/Impl/PFRdr.html#method-c-original_dest","(sock)","<p>Returns the [port, host] for the original destination of <code>sock</code>.\n<p><code>Sock</code> can be a Ruby socket or an EventMachine::Connection ...\n"],["packetthief","SSLTest::Config","SSLTest/Config.html#method-i-packetthief","()",""],["parse_args","SSLTest::Runner","SSLTest/Runner.html#method-i-parse_args","(args)",""],["passed?","SSLTest::SSLTestResult","SSLTest/SSLTestResult.html#method-i-passed-3F","()",""],["pause","SSLTest::Runner","SSLTest/Runner.html#method-i-pause","()",""],["pause?","SSLTest::Config","SSLTest/Config.html#method-i-pause-3F","()",""],["post_init","PacketThief::Handlers::AbstractSSLHandler","PacketThief/Handlers/AbstractSSLHandler.html#method-i-post_init","()","<p>Note that post_init dos not have access to the <em>sslsocket</em>. The\n<em>sslsocket</em> is not added until tls_begin …\n"],["post_init","PacketThief::Handlers::TransparentProxy","PacketThief/Handlers/TransparentProxy.html#method-i-post_init","()",""],["post_init","PacketThief::Handlers::TransparentProxy::ProxyConnection","PacketThief/Handlers/TransparentProxy/ProxyConnection.html#method-i-post_init","()",""],["post_init","SSLTest::TestListener","SSLTest/TestListener.html#method-i-post_init","()","<p>Checks whether the initial original destination certificate (without SNI\nhostname) matches the test hostname. …\n"],["preflight_for_cert","PacketThief::Handlers::SSLSmartProxy","PacketThief/Handlers/SSLSmartProxy.html#method-i-preflight_for_cert","(hostname=nil)","<p>Requests a certificate from the original destination.\n"],["print_results","SSLTest::SSLTestReport","SSLTest/SSLTestReport.html#method-i-print_results","(out)",""],["randomserial","CertMaker::CertificateSuiteGenerator","CertMaker/CertificateSuiteGenerator.html#method-i-randomserial","()",""],["receive_data","PacketThief::Handlers::AbstractSSLHandler","PacketThief/Handlers/AbstractSSLHandler.html#method-i-receive_data","(data)","<p>Override this to do something with the unecrypted data.\n"],["receive_data","PacketThief::Handlers::SSLTransparentProxy","PacketThief/Handlers/SSLTransparentProxy.html#method-i-receive_data","(data)",""],["receive_data","PacketThief::Handlers::SSLTransparentProxy::SSLProxyConnection","PacketThief/Handlers/SSLTransparentProxy/SSLProxyConnection.html#method-i-receive_data","(data)","<p>Transmit data sent by the destinaton to the client.\n"],["receive_data","PacketThief::Handlers::TransparentProxy","PacketThief/Handlers/TransparentProxy.html#method-i-receive_data","(data)",""],["receive_data","PacketThief::Handlers::TransparentProxy::ProxyConnection","PacketThief/Handlers/TransparentProxy/ProxyConnection.html#method-i-receive_data","(data)","<p>Transmit data sent by the destinaton to the client.\n"],["receive_data","SSLTest::InputHandler","SSLTest/InputHandler.html#method-i-receive_data","(data)","<p>Receives one character at a time.\n"],["redirect","PacketThief::Impl::Ipfw","PacketThief/Impl/Ipfw.html#method-c-redirect","(args={})",""],["redirect","PacketThief::Impl::Manual","PacketThief/Impl/Manual.html#method-c-redirect","(args={})",""],["redirect","PacketThief::Impl::Netfilter","PacketThief/Impl/Netfilter.html#method-c-redirect","(args={})",""],["redirect","PacketThief::Impl::PFDivert","PacketThief/Impl/PFDivert.html#method-c-redirect","(args={})",""],["redirect","PacketThief::Impl::PFRdr","PacketThief/Impl/PFRdr.html#method-c-redirect","(args={})",""],["redirect","PacketThief::RedirectRule","PacketThief/RedirectRule.html#method-i-redirect","(args)",""],["revert","PacketThief","PacketThief.html#method-c-revert","()","<p>Quietly ignore .revert calls if implementation is nil.\n"],["revert","PacketThief::Impl::Ipfw::IpfwRuleHandler","PacketThief/Impl/Ipfw/IpfwRuleHandler.html#method-i-revert","()","<p>Reverts all executed rules that this handler knows about.\n"],["revert","PacketThief::Impl::Manual::NullRuleHandler","PacketThief/Impl/Manual/NullRuleHandler.html#method-i-revert","()","<p>Reverts all executed rules that this handler knows about.\n"],["revert","PacketThief::Impl::Netfilter::IPTablesRuleHandler","PacketThief/Impl/Netfilter/IPTablesRuleHandler.html#method-i-revert","()","<p>Reverts all executed rules that this handler knows about.\n"],["revert","PacketThief::Impl::PFDivert::PFDivertRuleHandler","PacketThief/Impl/PFDivert/PFDivertRuleHandler.html#method-i-revert","()","<p>Reverts all executed rules that this handler knows about.\n"],["revert","PacketThief::Impl::PFRdr::PFRdrRuleHandler","PacketThief/Impl/PFRdr/PFRdrRuleHandler.html#method-i-revert","()","<p>Reverts all executed rules that this handler knows about.\n"],["run","PacketThief::Impl::Ipfw::IpfwRuleHandler","PacketThief/Impl/Ipfw/IpfwRuleHandler.html#method-i-run","(rule)","<p>Executes a rule and holds onto it for later removal.\n"],["run","PacketThief::Impl::Manual::NullRuleHandler","PacketThief/Impl/Manual/NullRuleHandler.html#method-i-run","(rule)","<p>Executes a rule and holds onto it for later removal.\n"],["run","PacketThief::Impl::Netfilter::IPTablesRuleHandler","PacketThief/Impl/Netfilter/IPTablesRuleHandler.html#method-i-run","(rule)","<p>Executes a rule and holds onto it for later removal.\n"],["run","PacketThief::Impl::PFDivert::PFDivertRuleHandler","PacketThief/Impl/PFDivert/PFDivertRuleHandler.html#method-i-run","(rule)","<p>Executes a rule and holds onto it for later removal.\n"],["run","PacketThief::Impl::PFRdr::PFRdrRuleHandler","PacketThief/Impl/PFRdr/PFRdrRuleHandler.html#method-i-run","(rule)","<p>Executes a rule and holds onto it for later removal.\n"],["run","PacketThief::RedirectRule","PacketThief/RedirectRule.html#method-i-run","()",""],["run","SSLTest::Runner","SSLTest/Runner.html#method-i-run","()",""],["run","SSLTest::SSLTestCase","SSLTest/SSLTestCase.html#method-i-run","()","<p>Sets up and launches the current test. It gathers the certificates and keys\nneeded to launch a TestListener …\n"],["run_test","SSLTest::Runner","SSLTest/Runner.html#method-i-run_test","(test)","<p>Runs a test based on the test description.\n"],["send_data","PacketThief::Handlers::AbstractSSLHandler","PacketThief/Handlers/AbstractSSLHandler.html#method-i-send_data","(data)","<p>Call this to send data to the other end of the connection.\n"],["send_to_client","PacketThief::Handlers::SSLTransparentProxy","PacketThief/Handlers/SSLTransparentProxy.html#method-i-send_to_client","(data)","<p>Sends data back to the client\n"],["send_to_client","PacketThief::Handlers::TransparentProxy","PacketThief/Handlers/TransparentProxy.html#method-i-send_to_client","(data)","<p>Sends data back to the client\n"],["send_to_dest","PacketThief::Handlers::SSLTransparentProxy","PacketThief/Handlers/SSLTransparentProxy.html#method-i-send_to_dest","(data)","<p>Queues up data to send to the remote host, only sending it if the\nconnection to the remote host exists. …\n"],["send_to_dest","PacketThief::Handlers::TransparentProxy","PacketThief/Handlers/TransparentProxy.html#method-i-send_to_dest","(data)","<p>Queues up data to send to the remote host, only sending it if the\nconnection to the remote host exists. …\n"],["servername_cb","PacketThief::Handlers::SSLServer","PacketThief/Handlers/SSLServer.html#method-i-servername_cb","(sslsock, hostname)","<p>Called when the client sends a hostname using the SNI TLS extension.\n<p>This method should return an OpenSSL::SSL::SSLContext …\n"],["servername_cb","PacketThief::Handlers::SSLSmartProxy","PacketThief/Handlers/SSLSmartProxy.html#method-i-servername_cb","(sslsock, hostname)","<p>def client_connected\n\n<pre># don't try to connect to dest here.</pre>\n<p>end\n"],["servername_cb","PacketThief::Handlers::SSLTransparentProxy","PacketThief/Handlers/SSLTransparentProxy.html#method-i-servername_cb","(sslsock, hostname)","<p>Set <em>dest_hostname</em> in addition to the default behavior.\n"],["servername_cb","SSLTest::TestListener","SSLTest/TestListener.html#method-i-servername_cb","(sslsock, hostname)","<p>Checks whether the original destination certificate after we handle the SNI\nhostname matches the test …\n"],["set_dest","PacketThief::Impl::Manual","PacketThief/Impl/Manual.html#method-c-set_dest","(host, port)",""],["split_chain","PacketThief::Util","PacketThief/Util.html#method-c-split_chain","(raw)","<p>Extracts all PEM encoded certificates out of a raw string and returns each\nraw PEM encoded certificate …\n"],["start","PacketThief::Handlers::SSLServer","PacketThief/Handlers/SSLServer.html#method-c-start","(host, port, *args, &block)",""],["stop_server","PacketThief::Handlers::SSLServer","PacketThief/Handlers/SSLServer.html#method-i-stop_server","()","<p>Stops the InitialListener sever handler that spawned this handler. Due to\nour use of EM.watch, we can’t …\n"],["stop_server","PacketThief::Handlers::SSLServer::InitialServer","PacketThief/Handlers/SSLServer/InitialServer.html#method-i-stop_server","()","<p>This must be called explicitly. EM doesn’t seem to have a callback for when\nthe EM::run call ends.\n"],["stop_testing","SSLTest::SSLTestCase","SSLTest/SSLTestCase.html#method-i-stop_testing","()","<p>Callback to cleanup and exit.\n"],["test_completed","SSLTest::SSLTestCase","SSLTest/SSLTestCase.html#method-i-test_completed","(actual_result)","<p>Called when a test completes or is skipped. It adds an SSLTestResult to the\nreport, and it cleans up …\n"],["testing_method","SSLTest::Config","SSLTest/Config.html#method-i-testing_method","()",""],["tests","SSLTest::Config","SSLTest/Config.html#method-i-tests","(test_list=nil)",""],["tls_begin","PacketThief::Handlers::AbstractSSLHandler","PacketThief/Handlers/AbstractSSLHandler.html#method-i-tls_begin","()","<p>Creates <em>sslsocket</em> from <em>tcpsocket</em> and <em>ctx</em>, and\ninitializes the handler’s internal state. Called from the …\n"],["tls_begin","PacketThief::Handlers::SSLClient","PacketThief/Handlers/SSLClient.html#method-i-tls_begin","()",""],["tls_failed_handshake","PacketThief::Handlers::AbstractSSLHandler","PacketThief/Handlers/AbstractSSLHandler.html#method-i-tls_failed_handshake","(e)","<p>Called right after accept_nonblock fails for some unknown reason. The only\nparameter contains the OpenSSL::SSL::SSLError …\n"],["tls_failed_handshake","PacketThief::Handlers::SSLTransparentProxy::SSLProxyConnection","PacketThief/Handlers/SSLTransparentProxy/SSLProxyConnection.html#method-i-tls_failed_handshake","(e)",""],["tls_failed_handshake","SSLTest::TestListener","SSLTest/TestListener.html#method-i-tls_failed_handshake","(e)","<p>If the handshake failed, then we believe the client rejected our cert\nchain.\n"],["tls_successful_handshake","PacketThief::Handlers::AbstractSSLHandler","PacketThief/Handlers/AbstractSSLHandler.html#method-i-tls_successful_handshake","()","<p>Called right after the SSL handshake succeeds. This is your “new”\n#post_init.\n"],["tls_successful_handshake","PacketThief::Handlers::SSLTransparentProxy","PacketThief/Handlers/SSLTransparentProxy.html#method-i-tls_successful_handshake","()","<p>Just calls client_connected to keep things straightforward.\n"],["tls_successful_handshake","PacketThief::Handlers::SSLTransparentProxy::SSLProxyConnection","PacketThief/Handlers/SSLTransparentProxy/SSLProxyConnection.html#method-i-tls_successful_handshake","()","<p>send on successful handshake instead of on post_init.\n"],["tls_successful_handshake","SSLTest::TestListener","SSLTest/TestListener.html#method-i-tls_successful_handshake","()","<p>If the client completes connecting, then they trusted our cert chain.\n"],["to_csv","SSLTest::SSLTestReport","SSLTest/SSLTestReport.html#method-i-to_csv","()",""],["to_h","SSLTest::SSLTestResult","SSLTest/SSLTestResult.html#method-i-to_h","()",""],["to_ipfw_command","PacketThief::Impl::Ipfw::IpfwRule","PacketThief/Impl/Ipfw/IpfwRule.html#method-i-to_ipfw_command","()",""],["to_netfilter_command","PacketThief::Impl::Netfilter::IPTablesRule","PacketThief/Impl/Netfilter/IPTablesRule.html#method-i-to_netfilter_command","()",""],["to_pf_command","PacketThief::Impl::PFDivert::PFDivertRule","PacketThief/Impl/PFDivert/PFDivertRule.html#method-i-to_pf_command","()",""],["to_pf_command","PacketThief::Impl::PFRdr::PFRdrRule","PacketThief/Impl/PFRdr/PFRdrRule.html#method-i-to_pf_command","()",""],["unbind","PacketThief::Handlers::AbstractSSLHandler","PacketThief/Handlers/AbstractSSLHandler.html#method-i-unbind","()","<p>Override this to do something when the socket is finished.\n"],["unbind","PacketThief::Handlers::SSLServer::InitialServer","PacketThief/Handlers/SSLServer/InitialServer.html#method-i-unbind","()",""],["unbind","PacketThief::Handlers::SSLTransparentProxy","PacketThief/Handlers/SSLTransparentProxy.html#method-i-unbind","()","<p>Start the closing process and close the other connection if it is not\nalready closing.\n"],["unbind","PacketThief::Handlers::SSLTransparentProxy::SSLProxyConnection","PacketThief/Handlers/SSLTransparentProxy/SSLProxyConnection.html#method-i-unbind","()","<p>Start the closing process and close the other connection if it is not\nalready closing.\n"],["unbind","PacketThief::Handlers::TransparentProxy","PacketThief/Handlers/TransparentProxy.html#method-i-unbind","()","<p>Start the closing process and close the other connection if it is not\nalready closing.\n"],["unbind","PacketThief::Handlers::TransparentProxy::ProxyConnection","PacketThief/Handlers/TransparentProxy/ProxyConnection.html#method-i-unbind","()","<p>Start the closing process and close the other connection if it is not\nalready closing.\n"],["unbind","SSLTest::InputHandler","SSLTest/InputHandler.html#method-i-unbind","()",""],["unbind","SSLTest::TestListener","SSLTest/TestListener.html#method-i-unbind","()","<p>Report our result.\n"],["where","PacketThief::RedirectRule","PacketThief/RedirectRule.html#method-i-where","(args)","<p>specify an original destination\n"],["write_buffer","PacketThief::Handlers::AbstractSSLHandler","PacketThief/Handlers/AbstractSSLHandler.html#method-i-write_buffer","()",""],["write_buffer=","PacketThief::Handlers::AbstractSSLHandler","PacketThief/Handlers/AbstractSSLHandler.html#method-i-write_buffer-3D","(rhs)",""],["README","","README_rdoc.html","","<p>TLSPretense — SSL/TLS Client Testing Framework\n<p>A test framework for testing SSL/TLS client certificate …\n"],["general_setup","","doc/general_setup_rdoc.html","","<p>TLSPretense Setup\n<p>The following sections cover a basic configuration to get TLSPretense up\nand running. …\n"],["linux_setup","","doc/linux_setup_rdoc.html","","<p>Setting Up Linux for Use With TLSPretense\n<p>To run TLSPretense on Linux, you need a system that has two …\n"]]}}